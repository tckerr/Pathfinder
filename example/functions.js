//-------------------------------------------------------
//MATH
//-------------------------------------------------------





//-------------------------------------------------------
//PATHFINDING 
//-------------------------------------------------------

function findPath(){

	//since js doesn't have pointers, we use a UID system to universally access pf_node objects. 

	//list of blocks who we've yet to check for the "best path"
    var openList = [];
	//list of blocks who've been moved out of the open list after checking their path options
    var closedList = [];
	//id of the current node we'll work with within the loop
	var cParent = 0;
	//bool to control whether our pathfinding algorithm is finished
    var notDone = true;
	//bool that indicates if there is no solution
    var impass = false;
	//initial pf_node generated by our starting point
    var start = new pf_Node( set_start, {}, set_end, true );
	//start.gCost = 0; 
	
	//create node to represent starting tile and push it's unique ID into open list
	nodes.push(start);
    openList.push(nodes[0].id);

    //loop as long as we arent on the final tile
	while (notDone){
 
		//no items to check, that means we don't have a path
        if (openList.length < 1){
            return false;
        }
		
		//put item with lowest fcost at back of array (best to check first)
        openList.sort( compareOL );	
		//set cparent equal to id of element we want to check
        cParent = openList[openList.length-1];
		//remove cparent from the open list and add it to closed instead
		openList.splice(openList.length-1, 1);		
        closedList.push(cParent); 
		//some basic computations to reduce redundancy
		cParentX = nodes[cParent].location['x'];
		cParentY = nodes[cParent].location['y'];
		
		//check if we are on the final tile
        if (cParentX != set_end['x'] || cParentY != set_end['y']){

            //get list of possible adjacent tiles to be scanned
            var adjacentTiles = pfc[cParentX][cParentY];			
			
            //iterate through the list of potential directions
            for ( var i = 0; i < adjacentTiles.length; i++ ){
			
				//represents whether a new node is in the open list already
                var inOpen = false;
				//represents whether a new node is in the closed list already
				var inClosed = false;
				
                //get relative location to cParent, EX: [-1, 1] would be SW
				var rel_loc = getRelativeLoc(cParent, adjacentTiles[i]);
				//apply that differential to cParent's, to get absolute location of the block in question
                var new_loc = sumVector(nodes[cParent].location, rel_loc );
				
				//go through open list and see if we already have a node for it				
                for ( var p = 0; p < openList.length; p++){
				
					//compare the location of our node to the current entry in open list
                    if ( compareVector2i(new_loc, nodes[openList[p]].location ) ){
					
						//if so, set var to record that it is
                        inOpen = true;
						
                        /*check if our g score is better using this node instead of parent
						*	nodes[openlist[p]] refers to the pf_node at the location of the block in question
						*	therefore, nodes[openlist[p]].parent is an ID #, so we use that to index into the nodes array again
						*/
                        if ( nodes[nodes[openList[p]].parent].gCost > nodes[cParent].gCost){
                            //use current cparent as this node's parent
                            nodes[openList[p].parent] = cParent;
							//calculate costs
                            nodes[openList[p]].setGCost();
                            nodes[openList[p]].setFCost();
                        }
                    }
                }

                if (!inOpen){
					//wasn't in the open -- so check if it's in the closed list
                    for ( var p = 0; p < closedList.length; p++){
                        if ( compareVector2i(new_loc, nodes[closedList[p]].location) ){
                            inClosed = true;
                            break;
                        }
                    }
                }

                //not in open or closed, so the pf_node hasn't been created. 
                if ( !inOpen && !inClosed ){
					//Create it here
                    var current = new pf_Node(new_loc, cParent, set_end, false);
					//push it into nodes and its id into the openlist
					nodes.push(current);
                    openList.push(current.id);
                }
            }
        }
		//if above if eval'd to true, we're on the final tile. End the algorithm
        else {
            notDone = false;
		} 
	}

    //steps is an array of ids that represent nodes from the end -> start
    var steps = [];

	//as long as the block (cparent) we're on has its own parent, it's not the "start point," so it needs to be added to the array of steps (we're working backwards now)
    while (!nodes[cParent].orphan){
		//push it into steps
        steps.push(cParent);
		//set our new item equal to its parent
        cParent = nodes[cParent].parent;
    }

	//mlist is an array of locations that represent progressive steps to the end point
    var mList = [];
    
	//go through our steps
	for ( var i = 0; i < steps.length; i++ ){
		//grab our locations and throw them into the mlist
		var x = nodes[steps[i]].location['x'];
		var y = nodes[steps[i]].location['y'];
		mList.unshift( { 'x': x, 'y': y } );
		//illustrate path on screen by adding class to affected blocks
		$('#'+x+'_'+y+'').addClass("traversed");
		labelStep( $('#'+x+'_'+y+''), steps.length-i);
	}
    return steps.length;
}

function getAdj(tileX, tileY){
	//returns array of strings that represent relative tiles to which we are allowed to path

    noN = noS = noW = noE = false; //bools that represent 
    var tN, tNE, tE, tSE, tS, tSW, tW, tNW;

    y = parseInt(tileY);
    x = parseInt(tileX);

    //if we are at the top, block ne n nw
    if (y < 1){
        tN = 1;
        tNE = 1;
        tNW = 1;
		noN = true;
    }
	//otherwise if were at bottom block se s sw
    else if (y >= AREAHEIGHT_PX/BLOCK_SIZE-1){ //-1 since the column indexing starts at 0
        tSE = 1;
        tS = 1;
        tSW = 1;
        noS = true;
    }

	//if at leftmost side, block west
    if (x < 1){
        tNW = 1;
        tW = 1;
        tSW = 1;
        noW = true;
    }
	//if at rightmost side, block east
    else if (x >= AREAWIDTH_PX/BLOCK_SIZE-1){
        tNE = 1;
        tE = 1;
        tSE = 1;
        noE = true;
    }

    //set variables to values in walls
    if (!noN){ //if we aren't totally rejecting north...
        tN = walls[y-1][x]; //get passability of northern block
        if (!noW){ tNW = walls[y-1][x-1];}
        if (!noE){ tNE = walls[y-1][x+1];}
    }
    if (!noS){ //if we aren't totally rejecting south...
        tS = walls[y+1][x]; //get passability of southern block
        if (!noW){ tSW = walls[y+1][x-1];}
        if (!noE){ tSE = walls[y+1][x+1];}
    }
    if (!noE){ tE = walls[y][x+1];}
    if (!noW){ tW = walls[y][x-1];}

    //forbid moving diagonally if walls are on either side
    if(tN == 1 && tE == 1){tNE = 1;}
    if(tN == 1 && tW == 1){tNW = 1;}
    if(tS == 1 && tE == 1){tSE = 1;}
    if(tS == 1 && tW == 1){tSW = 1;}

	//create array and push non-blocked directions in
	var passable = new Array();
	
    if (!tNW){ passable.push('nw') }
    if (!tN){ passable.push('n') }
    if (!tNE){ passable.push('ne') }
    if (!tE){ passable.push('e') }
    if (!tSE){ passable.push('se') }
    if (!tS){ passable.push('s') }
    if (!tSW){ passable.push('sw') }
    if (!tW){ passable.push('w') }

    return passable;
}

function getPFConfig(){
	
    var pfConfig = new Array();
	
	for( var i = 0 ; i < AREAWIDTH_BLOCK; i++ ){
		pfConfig[i] = new Array();
		for( var p = 0 ; p < AREAHEIGHT_BLOCK; p++ ){
			var ret = getAdj(i, p);
			pfConfig[i].push(ret);
		}
	} 
    return pfConfig;
}

function spotPF( locx, locy ){
	//recalculate a 3x3 grid of the pfConfig
    var x = parseInt(locx);
    var y = parseInt(locy);
	
	//re-set current tile
    pfc[x][y] = getAdj(x, y);

    if (y > 0){
	
        pfc[x][y-1] = getAdj(x, y - 1);
		
		if (x < AREAWIDTH_PX/BLOCK_SIZE - 1)
			pfc[x+1][y-1] = getAdj( x + 1, y - 1 );
			
		if (x > 0)
			pfc[x-1][y-1] = getAdj( x - 1, y - 1 );
	}
	
    if (y < AREAHEIGHT_PX/BLOCK_SIZE - 1){
	
        pfc[x][y+1] = getAdj(x, y + 1);
		
		if (x < AREAWIDTH_PX/BLOCK_SIZE - 1)
			pfc[x+1][y+1] = getAdj( x + 1, y + 1 );
			
		if ( x > 0)
			pfc[x-1][y+1] = getAdj( x - 1, y + 1 );
	}

    if ( x > 0 )
        pfc[x-1][y] = getAdj( x-1, y );

    if ( x < AREAWIDTH_PX/BLOCK_SIZE - 1 )
        pfc[x+1][y] = getAdj( x + 1, y );

}

function getNewPath(){
	clearPath();
	pfc = getPFConfig();
	findPath();
}

function getNewPathLite(){
	clearPath();
	if ( $(".block-start").length && $(".block-end").length ) {
		var pathAvail = false;
		var s1 = new StopWatch();
		s1.Start(); 
		pathAvail = findPath() ;
		s1.Stop();
		if (pathAvail){
			logMe("Pathing from [" + set_start['x'] + ', ' + set_start['y'] +'] to [' + set_end['x'] + ', ' + set_end['y']+"] took " + s1.ElapsedMilliseconds + "ms and has " + pathAvail + " steps.\n");
		} else {
			logMe("No path available.\n");
		}
	}
}
}

//-------------------------------------------------------
//CONSTRUCT 
//-------------------------------------------------------

function appendBlockRow(){
	var block_row = document.createElement('tr');
	block_row.setAttribute('class', 'block-row');
	block_row.setAttribute('height', BLOCK_SIZE); //height is that of one block
	block_row.setAttribute('width', AREAWIDTH_PX); //width is a full row
	$("#playable-area").append(block_row);
}

function appendBlock( element, row, column ){
	var block = document.createElement('td');
	block.setAttribute('class', 'block');
	block.setAttribute('height', BLOCK_SIZE); //height is that of one block
	block.setAttribute('width', BLOCK_SIZE); //width is a full row
	block.setAttribute('id', column+'_'+row);
	$(element).append(block);
}

function setStart(block){
	
	$(".block-start").removeClass("block-start");
	block.addClass("block-start");
	blockid = block.attr('id').split("_");
	set_start = { 'x': parseInt(blockid[0]), 'y': parseInt(blockid[1]) };
	changeMenuState(0);
	
	//place flag
	$("#flagstart").remove();
	$('#playable-area').append('<img src="img/flag.png" height="20px" id="flagstart"/>');
	$("#flagstart").css('top', 5 + blockid[1] * BLOCK_SIZE );
	$("#flagstart").css('left', 100 + blockid[0] * BLOCK_SIZE );
	
	logMe('Start point set to [' + blockid[0] + ', ' + blockid[1] +'].\n');
	
	//new path
	spotPF(blockid[0], blockid[1]);
	getNewPathLite();	
}

function setEnd(block){
	$(".block-end").removeClass("block-end");
	block.addClass("block-end");
	blockid = block.attr('id').split("_");
	set_end = { 'x': parseInt(blockid[0]), 'y': parseInt(blockid[1]) };
	changeMenuState(0);
	
	//flag
	$("#flagend").remove();
	$('#playable-area').append('<img src="img/flag.png" height="20px" id="flagend"/>');
	$("#flagend").css('top', 5 + blockid[1] * BLOCK_SIZE );
	$("#flagend").css('left', 100 + blockid[0] * BLOCK_SIZE );
	
	spotPF(blockid[0], blockid[1]);
	logMe('End point set to [' + blockid[0] + ', ' + blockid[1] +'].\n');
	getNewPathLite();
}

function buildWall(block){
	block.addClass("block-wall");
	//set value is pfconfig to 1
	blockid = block.attr('id').split("_");
	walls[blockid[1]][blockid[0]] = 1;
	
	spotPF(blockid[0], blockid[1]);
	getNewPathLite();
	
}

function removeWall(block){
	block.removeClass("block-wall");
	//set value in pfconfig back to 0
	blockid = block.attr('id').split("_");
	walls[blockid[1]][blockid[0]] = 0;
	spotPF( blockid[0], blockid[1] );
	getNewPathLite();
}

function clearAll(){
	changeMenuState(0);
	
	clearPath();
	clearWalls();
	set_start = set_end = {};
	
	$(".block-start").removeClass("block-start");
	$(".block-end").removeClass("block-end");
	
	$("#flagstart").remove();
	$("#flagend").remove();
}

function clearPath(){
	$(".traversed").removeClass("traversed");
	$(".steplabel").remove();
	pfn_incr = 0;
	nodes = [];
}

function clearWalls(){
	for ( var i = 0; i < walls.length; i++ ){
		for ( var p = 0; p < walls[0].length; p++ ){
			walls[i][p] = 0;
		}
	}	
	$(".block-wall").removeClass("block-wall");
	pfc = getPFConfig();	
}



//-------------------------------------------------------
//MISC 
//-------------------------------------------------------

function changeMenuState( option ){
	if( option === 0 || option === menustate){
		menustate = 0;
		$("#playable-area").css("cursor", "auto");
		$("#menu").children().removeClass("menu-selected");		
	} else {
		menustate = option;
		$("#playable-area").css("cursor", "crosshair");
		$('.menu-selected').removeClass("menu-selected");
		switch( option ){
			case 0:
				break;
			case 1:
				$("#setstart").addClass("menu-selected");
				break;
			case 2:
				$("#setend").addClass("menu-selected");
				break;
			case 3:
				$("#drawwalls").addClass("menu-selected");
				break;
		};
	}
}

function init(){
	//create blocks and init walls
	for( var i = 0 ; i < AREAHEIGHT_BLOCK; i++ ){
		walls[i] = [];
		appendBlockRow();
		var current_row = $("#playable-area").children('tr').last();
		for( var p = 0 ; p < AREAWIDTH_BLOCK; p++ ){
			walls[i][p] = 0;
			appendBlock( current_row, i, p );
		}
	}
		
	//track mouse state (for drawing)
	$(document).mousedown(function() {
		mdown = true;
	}).mouseup(function() {
		mdown = false;  
	});
	pfc = getPFConfig();
}

function scrollToBottom(textbox) {
   $('#debug').scrollTop($('#debug')[0].scrollHeight);
}

function logMe( text ){
	$("#debug").append(text);
	scrollToBottom();
}

function labelStep( block, step ){
	block.append('<p class="steplabel">'+step+'</p>');
	//block.children().css('top', 58 + blockid[1] * BLOCK_SIZE );
	//block.children().css('left', 134 + blockid[0] * BLOCK_SIZE );
}



//-------------------------------------------------------
//PF NODE "CLASS"
//-------------------------------------------------------

pf_Node.prototype.setFCost = function() {
	this.fCost = this.hCost + this.gCost;
};

pf_Node.prototype.setHCost = function(destination) {
	//calc manhattan distance btwn a given destination and our current location
	var total_x = Math.abs(destination['x']- this.location['x']);
	var total_y = Math.abs(destination['y'] - this.location['y']);

	this.hCost =  10 * ( total_x + total_y );
};

pf_Node.prototype.setGCost = function() {
	//figure out how much we've moved from it
	var moved_x = Math.abs(nodes[this.parent].location['x'] - this.location['x']);
	var moved_y = Math.abs(nodes[this.parent].location['y'] - this.location['y']);

	//if both !=0, then it's a diagonal (cost of 14)
	if ( moved_y != 0 && moved_x != 0)
		this.gCost = nodes[this.parent].gCost + 14;
	else //otherwise, its cost of 10
		this.gCost = nodes[this.parent].gCost + 10;
};

function pf_Node (in_loc, in_par, destination, isstart) {

	this.location = in_loc;
	this.inOpen = false;
	this.id = pfn_incr;
	pfn_incr++;
	
	if (isstart){
		this.parent = {};
		this.orphan = true;
		this.gCost = 0;
		this.setHCost(destination);
		this.setFCost();
	} else {
		this.parent = in_par;
		this.orphan = false;
		this.setGCost();
		this.setHCost(destination);
		this.setFCost();
	}
}


//-------------------------------------------------------
//STOPWATCH "CLASS"
//-------------------------------------------------------

StopWatch = function(){
    this.StartMilliseconds = 0;
    this.ElapsedMilliseconds = 0;
}  

StopWatch.prototype.Start = function(){
    this.StartMilliseconds = new Date().getTime();
}

StopWatch.prototype.Stop = function(){
    this.ElapsedMilliseconds = new Date().getTime() - this.StartMilliseconds;
}
